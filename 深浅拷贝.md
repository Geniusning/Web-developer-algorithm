## 1.浅拷贝
### 1.1、js中哪些方法实现了浅拷贝
#### Object.assign方式
```
let target = {}
let source = {a:{b:2}}
Object.assign(target,source)
console.log(target) //{a:{b:10}}
source.a.b = 20
console.log(source) // {a:{b:20}}
console.log(target) // {a:{b:20}}
```
从上面的例子我们可以看出，使用object.assign拷贝的对象是浅拷贝，改变源对象的a.b的值，目标对象a.b的值也相对应被改变了（因为他们是引用的同一个内存地址）。另外object.assign它不会拷贝对象的继承属性，
也不会拷贝对象的不可枚举属性，可以拷贝symbol类型的属性,请看一下例子
```
let obj1 = {a:{b:1},sym:symbol(1)}
Object.defineProperty(obj1,'innumberable',{
  value:"不可枚举属性",
  enumerable:false
})
let obj2 = {}
Object.assign = {obj2,obj1}
obj1.a.b = 10
console.log('obj1',obj1) // obj1 {a:{b:10},sym:symbol(1),innumberable:"不可枚举属性"}
console.log('obj2',obj2) // obj2 {a:{b:10},sym:symbol(1)}
```

#### 扩展运算符方式
```
let obj = {a:1,b:{c:1}}
let obj2 = {...obj}
obj.a = 2
console.log(obj1) //{a:2,b:{c:1}}
console.log(obj2) //{a:1,b:{c:1}}
obj.b.c = 10
console.log(obj1) //{a:2,b:{c:10}}
console.log(obj2) //{a:1,b:{c:10}}
```
从上面例子可以看出，如果是值类型的数据进行扩展运算符的拷贝是比较简单的

#### concat方式拷贝数组
```
let arr = [1,2,3]
let newArr = arr.concat()
newArr[1] = 100
console.log(arr)  //[1,2,3]
cosnole.log(newArr) //[1,100,3]
```

### 1.2 手工实现一个浅拷贝
```
const shallowClone = (target) => {
  if (typeof (target) === 'object' && target !== null) {
    const cloneTarget = Array.isArray(target) ? [] : {}
    for (const prop in target) {
      if (target.hasOwnProperty(prop)) {
        cloneTarget[prop] = target[prop];
      }
    }
    return cloneTarget
  } else {
    return target
  }
}
```

## 2 .深拷贝
### 2.1乞丐版（JSON.stringfy）
JSON.stringfy是目标开发过程中最常用的深拷贝方式了
```
  let obj = {a:1,b:[1,2,3]}
  let str = JSON.stringfy(obj)
  let obj2 = JSON.parse(str)
  console.log(obj2) //{a:1,b:[1,2,3]}
  obj1.a = 2
  obj1.b.push(4)
  console.log(obj1) = {a:2,b:[1,2,3,4]}
  console.log(obj2) //{a:1,b:[1,2,3]}
```
使用json.stringfy需要注意的问题

1.拷贝的对象的值如有函数，underfine,symbol这几种类型，经过JSON.stringfy序列化后的字符串中这个健值对会消失

2.拷贝Date引用类型会变成字符串

3.无法拷贝不可枚举对象

4.无法拷贝对象的原型链

5.拷贝正则对象会变成空对象

6.对象中有NAN,Infinite序列后变null

7.不能拷贝对象的循环引用 （obj[key] = obj）
```
使用一下代码测试
function Obj(){
  this.func = funciton () {console.log(1)}
  this.date = new Date()
  this.reg = /d+/
  this.NaN = NaN
  this.larget = Inifite
  this.obj = {a:1}
  this.sym = Symbol(1)
}

let obj = new Obj()
Object.defineProperty(obj,'innumberable',{
  value:"不可枚举属性",
  enumerable:false
})

console.log("obj",obj)
let str = JSON.stringfy(obj)
let obj2 = JSON.parse(str)
console.log('obj2',obj2)
```
